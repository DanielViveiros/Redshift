{"entities":[{"fqn":"/Community Queries","id":"067ce53b-d1d2-431a-9f3d-4765eb18eebf","parent_folder_id":"bb6de4af-1aad-493e-a9ee-b3e75cf58ed7","name":"Community Queries","entity_type":"FOLDER"},{"fqn":"/Community Queries/Redshift/Data Engineering/Generate a Time Dimension","id":"674dd774-ab7f-44d5-8bb2-e0bd9bf818f2","parent_folder_id":"876efc86-a0d7-4f28-861b-f728f2902064","name":"Generate a Time Dimension","entity_type":"SQL_ENTITY","description":"This set of queries will generate a DIM_DATE table with regularly columns and data to trend by.  You must enter a parameter of number of days to generate","content":"--This query will generate date rows for a date dimension\n--author:  Jeff Schlitt\n--date created:  8/1/2019\n--     Modified: 9/18/2019 - Added in full insert capability\n\ndrop table numbers;\ncreate table numbers\n(\n  number int PRIMARY KEY\n)\n;\n\n-- typically you will choose 2000-3000 rows.  Each row generated represents a day so if you want to \n-- generate for 1 year you put 365.\n\nselect  'truncate table numbers;'\nunion all\nselect 'insert into numbers values '\nunion all \nselect '(0)'\nunion all \nSELECT ',(' || generate_series(1,$enter_number_of_date_rows_to_generate,1) || ')'\nunion all \nselect ';' \n;\n\n--Cut and paste from query above into insert statement example shown below\n--Make sure that you have your preferences set higher than the number of rows you generated e.g. \n--if you put in 3000 for the generate series parameter you need to make sure your preferences are > 3000\n\n/*\ntruncate table numbers;\ninsert into numbers values \n(0)\n,(1)\n,(2)\n,(3)\n;\n\n\n*/\n\n\n\n\ndrop table dim_date;\nCREATE TABLE dim_date (\n  \"DateKey\"              INTEGER                     NOT NULL PRIMARY KEY,\n\n  -- DATE\n  \"BusinessDayDate\"            DATE                        NOT NULL,\n\n  -- YEAR\n  \"YearNumber\"          SMALLINT                    NOT NULL,\n  \"YearWeekNumber\"     SMALLINT                    NOT NULL,\n  \"YearDayNumber\"      SMALLINT                    NOT NULL,\n\n  -- QUARTER\n  \"QtrNumber\"           SMALLINT                    NOT NULL,\n\n  -- MONTH\n  \"MonthNumber\"         SMALLINT                    NOT NULL,\n  \"MonthName\"           CHAR(9)                     NOT NULL,\n  \"MonthDayNumber\"     SMALLINT                    NOT NULL,\n\n  -- WEEK\n  \"WeekDayNumber\"      SMALLINT                    NOT NULL,\n  \"WeekStart\"      DATE                        NOT NULL,\n  \"WeekEnd\"        DATE                        NOT NULL,\n\n  -- DAY\n  \"DayName\"             CHAR(9)                     NOT NULL,\n  \"DayIsWeekday\"       SMALLINT                    NOT NULL,\n  \"DayIsLastOfMonth\" SMALLINT                    NOT NULL\n) DISTSTYLE ALL SORTKEY (DateKey)\n;\n\ntruncate table dim_date;\nINSERT INTO dim_date\n(\n   \"DateKey\"\n  ,\"BusinessDayDate\"\n  ,\"YearNumber\"\n  ,\"YearWeekNumber\"\n  ,\"YearDayNumber\"\n\n  -- QUARTER\n  ,\"QtrNumber\"\n\n  -- MONTH\n  ,\"MonthNumber\"\n  ,\"MonthName\"\n  ,\"MonthDayNumber\"\n\n  -- WEEK\n  ,\"WeekDayNumber\"\n  ,\"WeekStart\"\n  ,\"WeekEnd\"\n\n  -- DAY\n  ,\"DayName\"\n  ,\"DayIsWeekday\"\n  ,\"DayIsLastOfMonth\"\n)\n  SELECT\n    cast(seq + 1 AS INTEGER)                                      AS DateKey,\n\n    -- DATE\n    datum                                                         AS BusinessDayDate,\n\n    -- YEAR\n    cast(extract(YEAR FROM datum) AS SMALLINT)                    AS YearNumber,\n    cast(extract(WEEK FROM datum) AS SMALLINT)                    AS YearWeekNumber,\n    cast(extract(DOY FROM datum) AS SMALLINT)                     AS YearDayNumber,\n\n    -- QUARTER\n    cast(to_char(datum, 'Q') AS SMALLINT)                         AS QtrNumber,\n\n    -- MONTH\n    cast(extract(MONTH FROM datum) AS SMALLINT)                   AS MonthNumber,\n    to_char(datum, 'Month')                                       AS MonthName,\n    cast(extract(DAY FROM datum) AS SMALLINT)                     AS MonthDayNumber,\n\n    -- WEEK\n    cast(to_char(datum, 'D') AS SMALLINT)                         AS WeekDayNumber,\n    date_trunc('week',datum)                                    AS WeekStart,\n    date_trunc('week',datum+7)                                   AS WeekEnd,\n\n    -- DAY\n    to_char(datum, 'Day')                                         AS DayName,\n    CASE WHEN to_char(datum, 'D') IN ('1', '7')\n      THEN 0\n    ELSE 1 END                                                    AS DayIsWeekday,\n    CASE WHEN\n      extract(DAY FROM (datum + (1 - extract(DAY FROM datum)) :: INTEGER +\n                        INTERVAL '1' MONTH) :: DATE -\n                       INTERVAL '1' DAY) = extract(DAY FROM datum)\n      THEN 1\n    ELSE 0 END                                                    AS DayIsLastOfMonth\n  FROM\n    -- Generate days for 81 years starting from 2000.\n    (\n      SELECT\n        '2016-01-01' :: DATE + number AS datum,\n        number                        AS seq\n      FROM numbers\n      WHERE number between 0 and 81 * 365 + 20\n    ) DQ\n  ORDER BY 1;\n\n-- review your data\n  select * from dim_date\n  order by dateKey;","type":"OTHER","platform":"Snowflake","executed_count":0},{"fqn":"/Community Queries/Redshift/Data Engineering","id":"876efc86-a0d7-4f28-861b-f728f2902064","parent_folder_id":"f817d4fd-5d49-4647-a6af-6c4c1481ecc7","name":"Data Engineering","entity_type":"FOLDER"},{"fqn":"/Community Queries/Redshift","id":"f817d4fd-5d49-4647-a6af-6c4c1481ecc7","parent_folder_id":"067ce53b-d1d2-431a-9f3d-4765eb18eebf","name":"Redshift","entity_type":"FOLDER"}]}